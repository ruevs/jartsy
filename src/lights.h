#ifndef JARTSY_LIGHTS_H
#define JARTSY_LIGHTS_H

#include "jartsyla.h"
#include "ray.h"
#include "material.h"
#include "entities.h"

class Light {
public:
    virtual Vector VectorTo(const Point &from) const = 0;
    virtual Ray RayToLight(const Point from) const = 0;
    virtual bool Intersect(const Ray &r, Intersection *ints) const = 0;
};

// An "ideal" point light source
class PointLight : public Light {
public:
    Point p;
    Material m;

    PointLight(Point pt, Material mat) : p(pt), m(mat){};

    inline Vector VectorTo(const Point &from) const override {
        return p - from;
    };

    inline Ray RayToLight(const Point from) const override {
        Vector lightDir = VectorTo(from);
        // It seems to me that the "shadowBias" suggested in lecture 8 is better served
        // by a non-zero ray minimum time.
        return {from, lightDir.WithMagnitude(1.), 0., 10 * LENGTH_EPS, lightDir.Magnitude()};
    }

    inline bool Intersect(const Ray &r, Intersection *ints) const override {
        // PAR@@@@@@@@ Presuming that the ray is the one generated by RayToLight!!!
        ints->ip = p;
        ints->n  = -r.d;
        ints->material = (Material *)&m; // PAR@@@ should Intersection material be a pointer?
        return true;

 /*
        Vector rayToLight      = VectorTo(r.o);
        Float rayLightDistance = rayToLight.Magnitude();
        rayToLight             = rayToLight.WithMagnitude(1.);
        const Float dot        = r.d.Dot(rayToLight);
        if(0 <= dot && LENGTH_EPS >= 1 - dot) {
            // If the ray direction and the vector from the ray origin to the point source
            // have a positive dot product very close to one then the ray "intersects" the
            // light source.
            ints->ip = p;
            ints->n  = -rayToLight;
//            ints->material->color = c;  // PAR@@@@@@@@@ Intensity? Inverse square law?
            return true;
        }
        return false;
*/
    };
};

// A parallel beam light coming from some direction 
// and filling all space. Like Sun light on Earth scale.
class SunLight : public Light {
public:
    Vector direction;
    Material m;

    SunLight(Vector d, Material mat) : direction(d), m(mat){};

    inline Vector VectorTo(const Point &from) const override {
        (void)from; // unused
        return -direction;
    };

    inline Ray RayToLight(const Point from) const override {
        Vector lightDir = VectorTo(from);
        // It seems to me that the "shadowBias" suggested in lecture 8 is better served
        // by a non-zero ray minimum time.
        return {from, lightDir.WithMagnitude(1.), 0., 10 * LENGTH_EPS,
                std::numeric_limits<Float>::max() /* parallel light from infinity */};
    }

    bool Intersect(const Ray &r, Intersection *ints) const override {
        // PAR@@@@@@@@ Presuming that the ray is the one generated by RayToLight!!!
        // PAR@@@@@@ how should I fill ints->ip
        ints->ip       = {std::numeric_limits<Float>::max(), std::numeric_limits<Float>::max(),
                    std::numeric_limits<Float>::max()};
        ints->n  = -r.d;
        ints->material = (Material *)&m; // PAR@@@ should Intersection material be a pointer?
        return true;
    };
};

#endif
